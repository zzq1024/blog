# 第一节：Linux奥义

### 命令

1.awk

统计一列中不同数据及重复次数，并获取数值最大的前两条：

```shell
awk 'sum[$1]++{for(i in sum) print sum[i],i}' test.txt |sort -nr|head -n 2
1.1.1.1        结果=>   2 1.1.1.1 
2.2.2.2	               1 2.2.2.2	
3.3.3.3					
4.4.4.4					
1.1.1.1.
```

```shell
$1~$n：当前记录的第n个字段，字段间由FS分隔
FS：输入字段分隔符 默认是空格
NF：当前记录中的字段个数，就是有多少列
NR：已经读出的记录数，就是行号，从1开始
```

2.cut文本处理

-b,–bytes：选取字节的列表，即选取每行的第N个字节；例：cut -b 2 cut.txt

-c,–characters：选取字符的列表，即选取每个的第N个字符。(英文字符下与-b没有区别，中文字符下，一个中文占据2-3个字节，所以存在中文的时候更倾向于用-c)；例：cut -c 2 cut.txt

-d,–delimiter：分隔符，默认为TAB

-f,–field：选取列的列表，即选取每行的第N列；例：cut -d , -f 1,2 cut.txt

3.grep命令

```shell
-i :  搜索时候忽略大小写
-v:  反转匹配，选择没有被匹配到的内容。
-w：匹配整词，精确地单词,单词的两边必须是非字符符号(即不能是字母数字或下划线)
-m num：当匹配内容的行数达到num行后,grep停止搜索,并输出停止前搜索到的匹配内容
-o: 只输出匹配的具体字符串,匹配行中其他内容不会输出
-n：输出匹配内容的同时输出其所在行号
-r：递归查找子目录
-E:grep -E '123|abc' filename,找出文件（filename）中包含123或者包含abc的行
-c：统计行数
```

4.sort

```shell
-b：忽略每行前面开始的空格字符,空格数量不固定时,该选项几乎是必须要使用的("-n"选项隐含该选项，测试发现都隐含)
-c：检查文件是否已经按照顺序排序，如未排序，会提示从哪一行开始乱序
-C：类似于"-c"，只不过不输出任何诊断信息。可以通过退出状态码1判断出文件未排序
-d：只处理英文字母、数字及空格，忽略其他的字符
-f：将小写字母视为大写字母
-h：使用易读性数字(例如:2K、1G)
-i：除了040至176之间的ASCII字符外(八进制0-177)，忽略其他的字符(忽略无法打印的字符如退格/换页键/回车)
-k：以哪个区间 (field) 来进行排序
-m：将几个排序好的文件进行合并，只是单纯合并，不做排序
-M：将前面3个字母依照月份的缩写进行排序
-n：依照数值的大小排序(防止以字符串排序)
-o<输出文件>：将排序后的结果存入指定的文件
-r：降序
-u：忽略相同行
-t<分隔字符>：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符
```



### 网络IO模型

对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：

1.等待数据准备 (Waiting for the data to be ready)

2.将数据从内核拷贝到进程中(Copying the data from the kernel to the process)

#### 阻塞IO（blocking IO）

在linux中，默认情况下所有的socket都是blocking，当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

**blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。**

一个简单的改进方案是在服务器端使用**多线程（或多进程）**，多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体使用多进程还是多线程，并没有一个特定的模式。**传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。**通常，使用pthread_create ()创建新线程，fork()创建新进程。

如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。这时可能会考虑使用**“线程池”或“连接池”**，“线程池”旨在减少创建和销毁线程的频率，“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。**所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少**。

#### **非阻塞IO（non-blocking IO**）

Linux下，可以通过设置socket使其变为non-blocking，**在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有，服务器线程可以通过循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用**。

non-blocking IO在执行recvfrom这个系统调用的时候，如果kernel的数据没有准备好，这时候不会block进程。但是当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内进程是被block的。

#### 多路复用IO（IO multiplexing）

**select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO**。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

多路复用IO需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。**使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求，用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。（多说一句：所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）**

在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。

相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄，linux提供了epoll更为高效的接口（遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难）。

##### IO多路复用的机制select，poll，epoll：

- **select**：本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理，单个进程可监视的fd数量被限制，即能监听端口的大小有限，2位机默认是1024个。64位机默认是2048；对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低；需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大；
- **poll**：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。**它没有最大连接数的限制**，原因是它是基于链表来存储的。
- **epoll**：没有最大并发连接的限制；效率提升不是轮询的方式，不会随着FD数目的增加效率下降，只有活跃可用的FD才会调用callback函数；内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

#### 异步IO（Asynchronous I/O）

**异步IO是真正非阻塞的**，它不会对请求进程产生任何的阻塞，用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

#### IO模型总结

调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还在准备数据的情况下会立刻返回。 

synchronous IO做”IO operation”的时候会将process阻塞，blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO；asynchronous IO则不一样，当进程发起IO操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。



### 网络拥塞

#### 原因

网络中存在瓶颈，该瓶颈的吞吐量小于节点单位时间发送的数据量；接收缓冲空间大于瓶颈处可用缓冲空间；

超量的数据无法从瓶颈路径发送，只好在缓存区排队，而缓冲区的大小有限制，积压的数据量超出缓存区大小，就会发生丢弃。

#### 恢复

基于丢包：超时重传对吞吐量的影响比较大，因为大量超时重传已明确表明网络瓶颈处发生了拥塞，发送方一般会将发送窗口降到一个相当低的值，重新缓慢增长发送窗口，以避免更严重的拥塞发生。高延迟的网络中发送窗口增长更加缓慢，少量的超时重传都会对吞吐量造成显著影响。因此多数TCP的拥塞避免算法会尽量避免超时重传，或减轻超时重传的影响。

基于延时：TCP vegas 里面的主要思想就是通过观察RTT的变化来判断当前网络是比较畅通还是比较拥堵，理由是持续增长的RTT被认为是发生拥塞的先兆；并规定diff的上限下限，作为判断当前网络状况的参考。当diff 大于上限时发送方主动减小发送窗口，当diff 小于下限时，发送方适当增加发送窗口。

### 写时复制

写入时复制是一种计算机程序设计领域的优化策略；其核心思想是，如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这个过程对其他的调用者是透明的（transparently）。此作法的主要优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作是可以共享同一份资源。

#### 应用：

##### 虚拟内存管理中的写时复制

一般把这种被共享访问的页面标记为只读。当一个task试图向内存中写入数据时，[内存管理单元](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83)（MMU）抛出一个异常，内核处理该异常时为该task分配一份物理内存并复制数据到此内存，重新向MMU发出执行该task的写操作。

##### 数据存储中的写时复制

[Linux]等的文件管理系统使用了写时复制策略。

[数据库]服务器也一般采用了写时复制策略，为用户提供一份snapshot。