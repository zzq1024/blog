# 第一节：Linux奥义

### 命令

1.awk

统计一列中不同数据及重复次数，并获取数值最大的前两条：

```shell
awk 'sum[$1]++{for(i in sum) print sum[i],i}' test.txt |sort -nr|head -n 2
1.1.1.1        结果=>   2 1.1.1.1 
2.2.2.2	               1 2.2.2.2	
3.3.3.3					
4.4.4.4					
1.1.1.1.
```

```shell
$1~$n：当前记录的第n个字段，字段间由FS分隔
FS：输入字段分隔符 默认是空格
NF：当前记录中的字段个数，就是有多少列
NR：已经读出的记录数，就是行号，从1开始
```

2.cut文本处理

-b,–bytes：选取字节的列表，即选取每行的第N个字节；例：cut -b 2 cut.txt

-c,–characters：选取字符的列表，即选取每个的第N个字符。(英文字符下与-b没有区别，中文字符下，一个中文占据2-3个字节，所以存在中文的时候更倾向于用-c)；例：cut -c 2 cut.txt

-d,–delimiter：分隔符，默认为TAB

-f,–field：选取列的列表，即选取每行的第N列；例：cut -d , -f 1,2 cut.txt

3.grep命令

```shell
-i :  搜索时候忽略大小写
-v:  反转匹配，选择没有被匹配到的内容。
-w：匹配整词，精确地单词,单词的两边必须是非字符符号(即不能是字母数字或下划线)
-m num：当匹配内容的行数达到num行后,grep停止搜索,并输出停止前搜索到的匹配内容
-o: 只输出匹配的具体字符串,匹配行中其他内容不会输出
-n：输出匹配内容的同时输出其所在行号
-r：递归查找子目录
-E:grep -E '123|abc' filename,找出文件（filename）中包含123或者包含abc的行
-c：统计行数
```

4.sort

```shell
-b：忽略每行前面开始的空格字符,空格数量不固定时,该选项几乎是必须要使用的("-n"选项隐含该选项，测试发现都隐含)
-c：检查文件是否已经按照顺序排序，如未排序，会提示从哪一行开始乱序
-C：类似于"-c"，只不过不输出任何诊断信息。可以通过退出状态码1判断出文件未排序
-d：只处理英文字母、数字及空格，忽略其他的字符
-f：将小写字母视为大写字母
-h：使用易读性数字(例如:2K、1G)
-i：除了040至176之间的ASCII字符外(八进制0-177)，忽略其他的字符(忽略无法打印的字符如退格/换页键/回车)
-k：以哪个区间 (field) 来进行排序
-m：将几个排序好的文件进行合并，只是单纯合并，不做排序
-M：将前面3个字母依照月份的缩写进行排序
-n：依照数值的大小排序(防止以字符串排序)
-o<输出文件>：将排序后的结果存入指定的文件
-r：降序
-u：忽略相同行
-t<分隔字符>：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符
```

#### 进程与线程

**进程**：操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。

进程间通信：管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存（Shared Memory）；套接字（Socket）

**线程**：有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。

一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；

进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；

不同进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，**一个线程死掉就等于整个进程死掉**，所以多进程的程序要比多线程的程序健壮，但在进程切换时，但在进程切换时，耗费资源较大，效率要差一些；但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

**线程安全**：多个线程同时处理同样一个逻辑的时候，可能造成数据混乱，没有按照我们预期的行为去执行，通常加锁来解决：

- 悲观锁：每个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。
- 乐观锁：就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为**非阻塞同步**；

**协程**：协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制，性能得到了很大的提升，不会像线程切换那样消耗资源；在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

**goroutine**:Goroutine是建立在线程之上的轻量级的抽象,它允许我们以非常低的代价在同一个地址空间中并行地执行多个函数或者方法。相比于线程，它的创建和销毁的代价要小很多，并且它的调度是独立于线程的。在golang中创建一个goroutine非常简单，使用“go”关键字即可，go的主函数也是跑在goroutine中。

Goroutine所需要的内存通常只有2kb，而线程则需要1Mb（500倍）

### 进程间通信（IPC）

IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等，其中 Socket和Streams支持不同主机上的两个进程IPC。

1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

### 写时复制

写入时复制是一种计算机程序设计领域的优化策略；其核心思想是，如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这个过程对其他的调用者是透明的（transparently）。此作法的主要优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作是可以共享同一份资源。

#### 应用：

##### 虚拟内存管理中的写时复制

一般把这种被共享访问的页面标记为只读。当一个task试图向内存中写入数据时，[内存管理单元](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83)（MMU）抛出一个异常，内核处理该异常时为该task分配一份物理内存并复制数据到此内存，重新向MMU发出执行该task的写操作。

##### 数据存储中的写时复制

[Linux]等的文件管理系统使用了写时复制策略。

[数据库]服务器也一般采用了写时复制策略，为用户提供一份snapshot。
