# 第二节：数据结构

### HashMap

结构：数组+单向链表

它存储的内容是键值对(key-value)映射，通过hash算法计算hash值，确定在table数组中的索引位置，如果得到相同哈希值(即产生了冲突)，会存储到同一个链表里，新加入的放在链头。

#### 分析HashMap的put方法

1.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

2.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；

3.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hash之前的key值；

4.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；

5.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树（利用红黑树快速增删改查的特点提高HashMap的性能），在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

6.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

#### 扩容机制(rehash)

当hashmap中的元素个数超过数组大小\*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16\*0.75=12的时候，就把数组的大小扩展为2\*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能,调整Hashtable的长度，将长度变成原来的(2倍+1)。

扩容过程：

(01) 将“旧的Entry数组”赋值给一个临时变量。

(02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”

(03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中

#### 线程安全的使用HashMap

- Hashtable：锁整个hash表，当一个线程访问 HashTable 的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用 put 方法时，另一个线程不但不可以使用 put 方法，连 get 方法都不可以。
- ConcurrentHashMap：实现方式---锁桶（或段），ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶，写线程才需要锁定，而读线程几乎不受限制。
- SynchronizedMap：调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的