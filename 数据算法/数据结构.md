# 第二节：数据结构

## 线性表

### 数组

数组是一种线性表数据结构；它用一组连续的内存空间，来存储一组相同类型的数据。

支持根据下标随机访问，插入、删除操作也因此变得比较低效(需要移动元素);

##### 数组为什么从0开始编号？

从数组存储的内存模型来看，下标定义是偏移(offset)，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size（数组元素大小），a[k]地址为：a[k]_address = bash_address + k * type_size。（寻址时不用减法操作）



### 链表

通过”指针“将一组零散的内存块串联起来使用；

插入、删除操作比较高效，查询需要遍历链表（时间复杂度为O(n)）;

#### 单链表

每个链表的节点除了存储数据之外，还需要记录下一个节点的地址（后继指针next）；

#### 循环链表

循环链表的尾结点指针是指向链表的头结点;

和单链表相比，循环链表的优点是从链尾到链头比较方便;

方便解决约瑟夫问题（类似于猴子选大王）；

#### 双向链表

支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点;

#### 相关算法

- 单链表反转
- 链表中环的检测
- 两个有序链表合并
- 删除链表倒数第n个节点
- 求链表的中间节点



### 栈

后进者先出，先进者后出，栈是一种“操作受限”的线性表;

##### 栈在函数调用中的应用

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。

为什么函数调用要用“栈”来保存临时变量呢？

从调用函数进入被调用函数，对于数据来说，变化的是什么呢，是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

##### 栈在表达式求值中的应用

编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个保存运算符的栈。

比如：34+13*9+44-12/3,我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较;如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。

##### 栈在括号匹配中的应用

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

#### 

### 队列

先进先出，一种操作受限的线性表数据结构。

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。



### 散列表

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

#### 散列函数的基本要求

- 散列函数计算得到的散列值是一个非负整数；
- 如果 key1 = key2，那 hash(key1) ==hash(key2) ；

- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)

#### 解决散列冲突

1.开放寻址法：如果出现了散列冲突，便从当期位置往后查找，看是否有空闲位置，直到找到为止（线性探测法）；删除操作时，不会把删除元素设置为空（原因是线性探索，找到第一个空闲位置，我们便会认定元素不存在，如果这个位置是后来删除的，就会导致原来的查找算法失效），而是标记为deleted；线性探测法存在很大问题，当散列表插入数据越来越多时，散列冲突发生的可能性增大，空闲位置越来越少，线性探测时间越来越久。

2.列表法：遇到哈希冲突时，散列值相同的元素放到相同槽位的链表中。

基于链表的冲突处理方法比较适合存储大对象、大数据量的散列表，而且更加灵活，支持更多的优化策略，比如用红黑树代替链表（抵御散列碰撞攻击）。



### HashMap

结构：数组+单向链表

它存储的内容是键值对(key-value)映射，通过hash算法计算hash值，确定在table数组中的索引位置，如果得到相同哈希值(即产生了冲突)，会存储到同一个链表里，新加入的放在链头。

#### 分析HashMap的put方法

1.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

2.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；

3.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hash之前的key值；

4.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；

5.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树（利用红黑树快速增删改查的特点提高HashMap的性能），在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

6.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

#### 扩容机制(rehash)

当hashmap中的元素个数超过数组大小\*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16\*0.75=12的时候，就把数组的大小扩展为2\*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能,调整Hashtable的长度，将长度变成原来的(2倍+1)。

扩容过程：

(01) 将“旧的Entry数组”赋值给一个临时变量。

(02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”

(03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中

注：一次性扩容机制不合适，会引起插入数据比较慢；所以当扩容时，新数据插入新哈希表中，旧哈希表中数据分批插入新哈希表（渐进式），期间的查询操作，先从新哈希表查，再从旧哈希表中查，而新添加的键值会放到新哈希表中。

#### 线程安全的使用HashMap

- Hashtable：锁整个hash表，当一个线程访问 HashTable 的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用 put 方法时，另一个线程不但不可以使用 put 方法，连 get 方法都不可以。
- ConcurrentHashMap：实现方式---锁桶（或段），ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶，写线程才需要锁定，而读线程几乎不受限制。
- SynchronizedMap：调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的



### 哈希算法

#### 应用

1、安全加密：

常用加密哈希算法有MD5（MD5消息摘要算法）、SHA（安全散列算法）、DES（数据加密标准）、AES（高级加密标准）。

2、唯一标识：

海量图库中，搜索一张图是否存在，不能单纯用图片的元信息（比如图片名称）来对比，可能名称相同但图片内容不相同。我们可以分别从图片的二进制码开头、中间、结尾各取100字节，放到一起，通过哈希算法（比如MD5）得到一个哈希字符串，作为唯一标识。

3、数据校验：

用BT下载电影时，在网络传输时，为了防止下载的文件块被篡改，可以将文件分成100块，分别取哈希值，并存在种子中，下载完成后，对下载好的文件块逐一求哈希值，进行比对。

4、散列函数：

设计一个散列表（哈希表）用到。

5、区块链：

区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。

区块头保存着 自己区块体 和 上一个区块头 的哈希值。

因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。

区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。

6、负载均衡：

通过哈希算法，对客户端IP或者回话ID计算哈希值，将哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。

7、数据分片：

就上面海量图片问题，如果有一亿图片，单机内存无法处理，我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。

8、分布式存储：

一致性哈希算法（解决分布式缓存问题）：数据的哈希值的范围是 [0, MAX]。我们将整个范围划分成m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。



### 树

#### 二叉树

每个节点最多有两个子节点；

叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作**完全二叉树**；

叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作**满二叉树**；

##### 如何存储一颗二叉树

- 链式存储法（链表）：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来，这种存储方式我们比较常用。
- 顺序存储法（数组）：如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点，根节点会存储在下标为 1 的位置；如果是一颗完全二叉树，仅仅会浪费一个下标为0的位置，如果是非完全二叉树，其实会浪费比较多的数组存储空间；如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式；

##### 二叉树的遍历

遍历时，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)；

- 前序遍历：先打印这个节点，然后再打印它的左子树，最后打印它的右子树;
- 中序遍历：先打印它的左子树，然后再打印它本身，最后打印它的右子树;
- 后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树；

#### 二叉查找树（二叉搜索树）

二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值；

中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为O（n）；

在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 O(n) 和O(logn)，分别对应二叉树退化成链表的情况和完全二叉树;

##### 相对于散列表，更常用二叉查找树的原因

- 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列;
- 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn);
- 笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高;
- 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定;
- 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间;

#### B树

即二叉搜索树：

- 所有非叶子结点至多拥有两个儿子（Left和Right）；
- 所有结点存储一个关键字；
- 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

#### B-树

是一种多路搜索树（并不是二叉的）：

1.定义任意非叶子结点最多只有M个儿子；且M>2；
 2.根结点的儿子数为[2, M]；
 3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
 4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
 5.非叶子结点的关键字个数=指向儿子的指针个数-1；
 6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
 7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的
 子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
 8.所有叶子结点位于同一层；

#### B+树

1.其定义基本与B-树同，除了：
2.非叶子结点的子树指针与关键字个数相同；
3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树
（B-树是开区间）；
5.为所有叶子结点增加一个链指针；
6.所有关键字都在叶子结点出现；

#### B-树和B+树的区别

B+树内节点不存储数据，所有 data 存储在叶节点，导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。

B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快；

由于B-树的节点都存了key和data，而B+树只有叶子节点存data，非叶子节点都只是索引值，没有实际的数据，这就时B+树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！

#### 总结

- B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于
   走右结点；
- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键
   字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
   中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
- B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率

### 堆
#### 堆结构
- 堆是一个完全二叉树，除了最后一层，其它层的节点都是满的，最后一层的节点都靠左排列；
- 堆中的每一个值都必须大于等于（或小于等于）其子树每个节点的值；

#### 堆操作
- 插入：将新插入的元素放到最后，从下往上堆化；
- 删除堆顶元素：将堆顶元素删除后，把最后一个节点放到堆顶，从上往下堆化；

#### 基于堆实现排序：
1.建堆(时间复杂度O(n))：
- 一个一个进行插入操作建堆
- 非叶子节点从后往前处理，每个节点都是从上往下堆化；
2.排序(时间复杂度nlogn)：
依次将堆顶元素移除

#### 应用
求topK