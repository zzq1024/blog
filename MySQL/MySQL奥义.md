# 第一节：MySQL奥义

### 基础

#### char与varchar

* char和varchar 后面的长度表示的是字符的个数，而不是字节数。

* 如果某个数据表里的数据行的长度是可变的，那么，为了节约存储空间，MySQL会把这个数据表里的固定长度类型的数据列转换为相应的可变长度类型．例外：长度小于4个字符的char数据列不会被转换为varchar类型。

* 区别：
  * char 表示定长，长度固定，varchar表示变长，即长度可变
  * char最多能存放的**字符**个数 255，和编码无关；varchar最大有效长度是 65532 字节，在varchar存字符串的时候，第一个字节是空的，不存任何的数据，然后还需要两个字节来存放字符串的长度。所以有效长度就是 65535 - 1 - 2 = 65532字节，字符根据编码来定。
  * char的效率高，没有碎片，尤其更新比较频繁的时候，方便数据文件指针的操作，varchar更新数据需要重新计算长度
  * varchar相对来说比较灵活，可动态分配空间，char设置长度不合理时可能会浪费空间

#### redo log与binlog

* redo log是innodb引擎提供的，binlog是mysql server自带的；
* redo log 记录 做了什么改动（比如把某个字段从0改成了1），binlog 记录 是怎么修改的（记录sql语句或者 记录更新前后的行）
* redo log 记录的，即使异常重启，都会刷新到磁盘（满血复活），而 bin log 记录的， 则主要用于备份



### 事务

#### 特性

* **原子性**：事务中包含的程序作为数据库的逻辑工作单位，它对数据库中的数据进行操作时，要么全部执行，要么都不执行
* **一致性**：一个事务执行前和执行后，数据库都必须要处于一致性的状态。（你给小A的卡里转了500块，不管怎么样你卡里的钱和小A卡里的钱的总和是不变的。）
* **隔离性**：指在并发的事务是相互隔离的。即一个事务的内部操作及正在操作的数据必须被封锁起来，不会被其他的事务来企图修改。
* **持久性**：持久性是指当数据库系统出现故障了，要确保已经提交的事务的更新是不会丢失的。即数据库中的数据的修改是永久性的。就算系统出现了故障，我们也可以使用数据库的备份和恢复来保证数据的修改。

#### 事务的隔离级别

* 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他事务中未提交事务修改的数据。（会出现脏读、不可重复读、幻读）

* 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 。（会出现不可重复读、幻读）

* 可重复读(Repeated Read)：可重复读。同一事务中所有的 查询均读取第 一次读取时已确定的快照，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读。（但是还存在幻象读）

* 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，在事务中的任何时候所看到的数据都是事务启动时刻的状态，不论在这期间有没有其他事务已经修改了某些数据并提交。

  对于高并发应用来说，为了尽可能保证数据的一致性，自然是事务隔离级别越高越好。但是，隔离级别越低，事务请求的锁越少或保持锁的时间就越短，性能越好。虽然 Innodb 存储引擎默认的事务隔离级别是 REPEATABLE READ，但实际上在我们大部分的应用场景 下，都只需要 READ COMMITED 的事务隔离级别就可以满足需求了。

  **脏读** :一个事务读取到另一事务未提交的更新数据
  **不可重复读 **: 在同一事务中,多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事务已提交的更新数据. 相反, “可重复读”在同一事务中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据。
  **幻读 **:一个事务读到另一个事务已提交的insert数据

#### 事务的机制

事务的机制是通过视图来实现的并发版本控制(MVCC), 不同的事务隔离级别创建读视图的时间点不同。

在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图；在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的；“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

#### 启动方式

1. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事物就启动了，而且并**不会自动提交**。这个事物持续存在直到你主动执行commit或rollback语句，或者断开连接；导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

2. set autocommit=1，显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是rollback；事务开始时需要主动执行一次“begin”，多一次交互。

   START TRANSACTION 后，只有当commit数据才会生效，ROLLBACK后就会回滚；如果没有START TRANSACTION ，执行每个SQL自动提交，调用ROLLBACK是没有用的。

3. 在set autocommit=1情况下，用begin启动事务，执行commit work and chain，则是提交事务并启动下一个事务，这样省去了再次执行begin语句的开销。



### 存储引擎

#### MyISAM和InnoDb区别

* innodb支持事务
* innodb支持外键
* innodb支持行锁
* myisam数据和索引分开放，innodb数据和索引放一起；
* 索引表：myisam叶子节点存放数据地址；innodb叶子节点存放真实的数据记录。（原因如上）
* myisam查询快，innodb写入快；

#### 为什么并发高时InnoDb写入快

* InnoDb支持行级锁，写入时只锁一行，myisam写入时会锁表
* 更新数据时，innodb只需要修改叶子节点，myisam需要修改索引结构（改动大）

#### 为什么MyISAM查询速度快（InnoDb维护的东西多）

* INNODB要缓存数据块，MYISAM只缓存索引块，这中间还有换进换出的减少
* innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快
* INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护

#### Innodb行级锁和事务性，容易产生死锁，优化建议：

* 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁;
* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
* 对于非常容易产生 锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率

#### InnoDB锁

**共享锁（s）**：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
**排他锁（Ｘ）**：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。SELECT * FROM table_name WHERE ... FOR UPDATE。

* update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型
* 加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制
* 如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁
* InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
* 在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件
* 选择合理的事务大小，小事务发生锁冲突的几率也更小



### 优化

#### 数据库查询优化

* 永远用小结果集驱动大的结果集
* 只取出自己需要的 Columns
* 仅仅使用最有效的过滤条件
* 尽可能避免复杂的 Join 和子查询（减少锁表）,分解为几个小查询
* 使用count(*)获取行数效率高，count(列名)只记录非NULL的列
* like 'word%'可以用到缓存，'%word%'用不到缓存
* 分区partition by，分表分库

#### 建立索引原则

* 最左前缀匹配原则
* 尽量选择区分度高的列作为索引
* 索引列不能参与计算
* 尽量的扩展索引，不要新建索引
* 索引字段长度尽量的小
* 较频繁的作为查询条件的字段应该创建索引,更新非常频繁的字段不适合创建索引



### 架构

#### MySQL主从复制和读写分离

MySQL读写分离基本原理是让master数据库处理写操作，slave数据库处理读操作。master将写操作的变更同步到各个slave节点。MySQLProxy实际上是在客户端请求与MySQLServer之间建立了一个连接池。所有客户端请求都是发向MySQLProxy，然后经由MySQLProxy进行相应的分析，判断出是读操作还是写操作，分发至对应的MySQLServer上。对于多节点Slave集群，也可以起做到负载均衡的效果。

MySQL读写分离能提高系统性能的原因在于：

* 物理服务器增加，机器处理能力提升。拿硬件换性能。
* 主从只负责各自的读和写，极大程度缓解X锁和S锁争用。
* slave可以配置myisam引擎，提升查询性能以及节约系统开销。
* master直接写是并发的，slave通过主库发送来的binlog恢复数据是异步。
* slave可以单独设置一些参数来提升其读的性能。
* 增加冗余，提高可用性。

#### MySQL安全设置

* 定期做数据备份
* 不给root权限，合理安排权限
* 关闭远程访问
* 设置MySQL数据文件的权限