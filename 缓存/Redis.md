# 第一节：Redis

### 基础

#### Redis如何淘汰过期的keys

Redis keys过期有两种方式：被动和主动方式。
当一些客户端尝试访问它时，key会被发现并主动的过期。
当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。

#### Redis内存回收

高版本的Redis中当内存达到极限时，内存淘汰策略主要采用了6种方式进行内存对象的释放操作：

- volatile-lru:从设置了过期时间的数据集中，选择最近最久未使用的数据释放
- allkeys-lru:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放
- volatile-random:从设置了过期时间的数据集中，随机选择一个数据进行释放
- allkeys-random:从数据集中(包括了设置过期时间以及未设置过期时间)随机选择一个数据进行入释放
- volatile-ttl：从设置了过期时间的数据集中，选择马上就要过期的数据进行释放操作
- noeviction：不删除任意数据(但redis还会根据引用计数器进行释放),这时如果内存不够时，会直接返回错误

默认的内存策略是noeviction [redis.conf：maxmemory-policy noeviction]

#### Redis持久化

- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.
- AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.

#### 数据结构

数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。

##### String（字符串）

字符串类型实际上可以是字符串（简单的字符串、复杂的字符串（xml、json）、数字（整数、浮点数）、二进制（图片、音频、视频）），但最大不能超过512M；

应用：缓存功能；计数器；共享session；频率限制；

##### Hash（哈希）

Hash是一个string类型的field和value的映射表（键值对）；

应用：hash特别适合用于存储对象，可以Hash数据结构来存储用户信息，商品信息等等。

##### List（列表）

可以队列表两端插入（pubsh）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下表的元素等，列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

应用：文章列表；关注列表；栈、队列；消息队列（不建议）；

##### Set（集合）

集合类型也是用来保存多个字符串的，但和列表不同的是集合中不允许有重复的元素，并且集合中的元素是无序的，不能通过索引下标获取元素，redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集；

应用：标签；随机数；微博共同关注、共同喜好

##### Sorted Set（有序集合）

保留了集合不能有重复成员的特性，但不同得是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数，作为排序的依据。

应用：排行榜

##### BitMap
setbit KEY_NAME OFFSET VALUE;offset是偏移量,value只能是0,1
应用：记录登录次数（活跃度）

#### 脚本与管道
如果是组织大量的、无依赖关系的命令，可以选择管道，当然也可以选择脚本。
如果命令之间有依赖关系，比如后续的命令需要处理先前命令的返回值，只能选择脚本。

#### 事务
特性：
事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

对于发生在 EXEC 执行之前的错误，如果有命令在入队时失败，调用 EXEC 命令时，拒绝执行并自动放弃这个事务。
至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。
这样做法的优点：
- Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。
- 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

#### phpredis:connect与pconnect

* connect：脚本结束之后连接就释放了。

* pconnect：脚本结束之后连接不释放，连接保持在php-fpm进程中。

  所以使用pconnect代替connect，可以减少频繁建立redis连接的消耗。

  [pconnect弊端](https://www.v2ex.com/t/95635)
